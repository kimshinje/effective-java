# 아이템 10. equals는 일반 규약을 지켜 재정의하라

## equals를 재정의하지 않아야 하는 경우
#### 각 인스턴스가 본질적으로 고유하다.
값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 여기 해당한다. Thread가 좋은 예로, Object의 equals 메서드는 이러한 클래스에 딱 맞게 구현되었다.

#### 인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다. 
예컨대 java.util.regex.pattern은 equals를 재정의해서 두 Pattern의 인스턴스가 같은 정규표현식을 나타내는지를 검사하는, 즉 논리적 동치성을 검사하는 방법도 있다. 하지만 설계자는 클라이언트가 이 방식을 원하지 안헉나 애초에 필요하지 않다고 판단할 수도 있다. 설계자가 후자로 판단했다면 Object의 기본 equals만으로 해결된다. 

#### 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
예컨대 대부분의 Set 구현체는 AbstractSet이 구현한 equals를 상속받아 쓰고, List 구현체들은 AbstractList로부터, Map 구현체들은 AbstractMap으로부터 상속받아 그대로 쓴다.

#### 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다. 
여러분이 위험을 철저히 회피하는 스타일이 아니라 equals가 실수로라도 호출되는 걸 막고 싶다면 다음처럼 구현해두자. 
```java
@Override public boolean equals(Object 0) {
    throw new AssertionError();
}
```

## equals를 재정의해야 할 때
객체 식별성(object identity; 두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때. 주로 값 클래스(Integer와 String처럼 값을 표현하는 클래스)들이 여기에 해당한다.

두 값 객체를 equals로 비교하는 프로그래머는 객체가 같은지가 아니라 값이 같은지를 알고 싶어 할 것이다. equals가 논리적 동치성을 확인하도록 재정의해두면, 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에 부응함은 물론 Map의 키와 Set의 원소로 사용할 수 있게 된다. 

값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스(아이템 1)라면 equals를 재정의하지 않아도 된다. Enum(아이템 34)도 여기에 해당한다. 이런 클래스에서는 어차피 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않으니 논리적 동치성과 객체 식별성이 사실상 똑같은 의미가 된다. 따라서 Object의 equals가 논리적 동치성까지 확인해준다고 볼 수있다. 

equals 메서드를 재정의할 때는 반드시 일반 규약을 따라야 한다. 다음은 Object 명세에 적인 규약이다. 이 규약을 어기면 프로그램이 이상하게 동작하거나 종료될 것이고, 원인이 되는 코드를 찾기도 굉장히 어려울 것이다. 

> equals 메서드는 동치관계(equivalence relation)를 구현하며, 다음을 만족한다.
>
> - **반사성(reflexivity)**: null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true다.
> - **대칭성(symmetry)**: null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true면 y.equals(x)도 true다.
> - **추이성(transitivity)**: null이 아닌 모든 참조 값 x, y, z에 대해, x.equals(y)가 true고 y.equals(z)도 true면 x.equals(z)도 true다.
> - **일관성(consistency)**: null이 아닌 모든 참조 값 x, y에 대해, x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다. 
> - **null-아님**: null이 아닌 모든 참조 값 x에 대해, x.equals(null)은 false다.

이 Object 명세에서 말하는 동치관계란 무엇일까? 쉽게 말해, 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산이다. 이 부분집합을 동치류(equivalence class; 동치 클래스)라 한다. equals 메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다. 이제 동치관계를 만족시키기 위한 다섯 요건을 하나씩 살펴보자.

## 반사성
    객체는 자기 자신과 같아야 한다는 뜻. 이 요건은 일부러 어기는 경우가 아니라면 만족시키지 못하기가 더 어려워 보인다. 이 요건을 어긴 클래스의 인스턴스를 컬렉션에 넣은 다음 contains 메서드를 호출하면 방금 넣은 인스턴스가 없다고 답할 것이다. 